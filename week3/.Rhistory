ls()
a <- 4
a
a*a
a_squared <- a*a
sqrt(a_squared)
v<-c(0,1,2,3,4)
?c
is.vector((v))
mean(v)
var(v)
median(v)
sum(v)
prod(v+1)
?prod
v+1
length(v)
wing.width.cm <- 1.2
wing.length.cm <- c(4.7, 5.2, 4.8)
wing.
x <- (1 + (2*3))
x = 2 +
li = list(c(1,2,3))
li[3]
li[2]
li[1]
li[[1]]
class(li)
View(li)
View(li)
li=list(1,2,3)
li[1]
li[2]
li[[2]]
li[3]
as.integer(3.1)
as.numeric(4)
as.roman(155)
as.character(155)
as.logical(5)
as.logical(0)
?logical
1E4
1e4
5e-2
a <- 5
is.vector(a)
v1<-c(0.02,0.5,1)
v2<-c("a", "bc", "def", "ghij")
v3<-c(TRUE, TRUE, FALSE)
v1;v2;v3
mat1<-matrix(1:25,5,5)
mat1
mat1<-matrix(1:25,5,5, byrow=TRUE)
mat1
arr1<-array(1:50, c(5,5,2))
arr1
mat1[1,1]<-"one"
mat1
MyMat=matrix(1:8,4,4)
MyMat
MyDF = as.data.frame(MyMat)
MyDF
object.size(MyMat)
object.size(MyDF)
MyList <- list(species=c("Qr", "Fe"), age = c(123,84))
MyList
col1<-1:10
col1
col2<-LETTERS{1:10}
col2<-[LETTERS]
col2<-LETTERS[1:10]
col3<-runif(10)
mydf <- data.frame(col1,col2,col3)
mydf
str(mydf)
years <- 1990:2009
years
years <- 2009:1990
years
seq(1,10,0.5)
myvar<-c("a", "b", "c", "d", "e")
myvar[1]
myvar[4]
myvar[c(1,1,5,5)]
v <- c(0,1,2,3,4)
v[3]
v[1:3]
v[-3]
mat1 <- matrix(1:25,5,5, byrow=TRUE)
mat1
mat1[1,]
mat1[,1]
a ,- c(1,5)+2
a <- c(1,5)+2
a
paste("Year is:", 1990:2000)
getwd()
setwd(documents/CMEECourseWork/week3)
setwd(Documents/CMEECourseWork/week3)
setwd("~/Documents/CMEECourseWork/week3")
mydata <- read.csv("data/trees.csv")
ls(pattern = "my*")
class(mydata)
head(mydata)
str(mydata)
write.csv(mydata, "results/MyData.csv")
?append
?write.table
MyData <- read.csv("../data/trees.csv", header = TRUE) #import with headers
MyData <- read.csv("data/trees.csv", header = TRUE) #import with headers
View(MyData)
write.csv(MyData, "../results/MyData.csv") #write it as a new file
write.csv(MyData, "results/MyData.csv") #write it as a new file
write.table(MyData[1,], file = "results/MyData.csv", append=TRUE) #append to it
write.csv(MyData, "results/MyData.csv", row.names=TRUE) #write row names
write.table(MyData, "../results/MyData.csv", col.names=FALSE) #ignore column names
write.table(MyData, "results/MyData.csv", col.names=FALSE) #ignore column names
write.csv(MyData, "results/MyData.csv") #write it as a new file
source("basic_io.R")
source(code/basic_io.R)
getwd()
ls()
source(/code/basic_io.R)
source("code/basic_io.R")
source("/code/basic_io.R")
source("./code/basic_io.R")
write.table(MyData, "results/MyData.csv", col.names=FALSE) #ignore column names
source("./code/basic_io.R")
source("./code/basic_io.R")
source(code/control_flow.R)
source(./code/control_flow.R)
source("./code/control_flow.R")
source("./code/control_flow.R")
source("./code/control_flow.R")
source("./code/control_flow.R")
source("./code/control_flow.R")
source("./code/control_flow.R")
source("./code/break.R")
source("./code/break.R")
source("./code/break.R")
source("./code/next.R")
# a boilerplate R script
MyFunction <- function(Arg1, Arg2) {
#statements involving arguments:
print(paste("Argument", as.character(Arg1), "is a", class(Arg1)))
print(paste("Argument", as.character(Arg2), "is a", class(Arg2)))
return(c(Arg1, Arg2))
}
MyFunction(1,2)
MyFunction("Riki", "Tiki")
source("./code/R_conditionals.R")
source("./code/R_conditionals.R")
source("./code/next.R")
source("./code/R_conditionals.R")
is.power2(4)
is.prime(3)
is.even(6)
source("./code/R_conditionals.R")
is.even(6)
is.power2(5)
source("./code/next.R")
TreeHeight <- function(degrees, distance) {
radians <- degrees * pi / 180
height <- distance * tan(radians)
print(paste("Tree height is:", height))
return (height)
}
TreeHeight(37, 40)
source("./code/TreeHeight.R")
a <- 1.0
class(a)
clear
rm(list = ls())
a <- 1.0
class(a)
float a
float b
M <- matrix(runif(1000000),1000,1000)
View(M)
source("code/Vectorize1.R")
source("code/Vectorize1.R")
NoPreallocFun <- function(x){
a<-vector()
for (i in 1:x) {
a <- c(a,i)
print(a)
print(object.size(a))
}
}
system.time(NoPreallocFun(10))
PreallocFun <- function(x){
a<-rep(NA,x)
for(i in 1:x){
a[i] <- i
print(a)
print(object.size(a))
}
}
system.time(PreallocFun(10))
source("code/preallocate.R")
system.time(NoPreallocFun(1000))
system.time(PreallocFun(1000))
source("code/preallocate.R")
source("code/preallocate.R")
source("code/preallocate.R")
source("code/preallocate.R")
source("code/preallocate.R")
source("code/preallocate.R")
source("code/preallocate.R")
## Build a random matrix
M<- matrix(rnorm(100), 10,10)
##Take the mean of each row
RowMeans <- apply(M,1,mean)
print(RowMeans)
## Build a random matrix
M<- matrix(rnorm(100), 10,10)
##Take the mean of each row
RowMeans <- apply(M,1,mean)
print(RowMeans)
# Now the varience
RowVars <- apply(M,1,var)
print(RowVars)
# by column
ColMeans <- apply(M,2,mean)
print(ColMeans)
m = matrix({1,2},{3,4})
m = matrix({1 2},{3 4})
m <- matrix(1:4,2,2)
sum(m)
SomeOperation<-function(v){ #if the sum of all components of matrix is
#positive, the components are multiplied by 100, if not nothingn happens
if (sum(v)>0){
return(v*100)
} else{
return(v)
}
}
M <- matrix(rnorm(100),10,10)
print(apply(M,1,SomeOperation))
M <- matrix(rnorm(100),10,10)
print(apply(M,1,SomeOperation))
## A function to take a sample of size n from a population (popn) and
#return its mean
myexperiment <- function(popn,n){
pop_sample <- sample(popn,n,replace=FALSE)
return(mean(pop_sample))
}
##calculate means using a for loop - no preallocation
loopy_sample1 <- function(popn,n,num){
result1<-vector() # initialise empty vector of size 1
for(i in 1:num){
result1 <- c(result1, myexperiment(popn,n))
}
return(result1)
}
set.seed(12345)
popn<-rnorm(10000)
hist(popn)
source("code/sample.R")
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## A function to take a sample of size n from a population (popn) and
#return its mean
myexperiment <- function(popn,n){
pop_sample <- sample(popn,n,replace=FALSE)
return(mean(pop_sample))
}
## A function to take a sample of size n from a population (popn) and
#return its mean
myexperiment <- function(popn,n){
pop_sample <- sample(popn,n,replace=FALSE)
return(mean(pop_sample))
}
##calculate means using a for loop - no preallocation
loopy_sample1 <- function(popn,n,num){
result1<-vector() # initialise empty vector of size 1
for(i in 1:num){
result1 <- c(result1, myexperiment(popn,n))
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(,num) #Preallocate expected size
for(i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
result3 <- vector("list", num) #Preallocate expected size
for(i in 1:num) {
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
rm(list=ls)
rm(list=ls())
set.seed(12345)
popn<-rnorm(10000)
hist(popn)
###### Functions ######
## A function to take a sample of size n from a population (popn) and
#return its mean
myexperiment <- function(popn,n){
pop_sample <- sample(popn,n,replace=FALSE)
return(mean(pop_sample))
}
##calculate means using a for loop - no preallocation
loopy_sample1 <- function(popn,n,num){
result1<-vector() # initialise empty vector of size 1
for(i in 1:num){
result1 <- c(result1, myexperiment(popn,n))
}
return(result1)
}
## To run "num" iterations of the experiment using a FOR loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num) {
result2 <- vector(,num) #Preallocate expected size
for(i in 1:num) {
result2[i] <- myexperiment(popn, n)
}
return(result2)
}
## To run "num" iterations of the experiment using a FOR loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num) {
result3 <- vector("list", num) #Preallocate expected size
for(i in 1:num) {
result3[[i]] <- myexperiment(popn, n)
}
return(result3)
}
## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num) {
result4 <- lapply(1:num, function(i) myexperiment(popn, n))
return(result4)
}
## To run "num" iterations of the experiment using vectorization with sapply:
sapply_sample <- function(popn, n, num) {
result5 <- sapply(1:num, function(i) myexperiment(popn, n))
return(result5)
}
n<-100
num<-10000
print("Using loops without preallocation on a vector took:" )
print(system.time(loopy_sample1(popn, n, num)))
print("Using loops with preallocation on a vector took:" )
print(system.time(loopy_sample2(popn, n, num)))
print("Using loops with preallocation on a list took:" )
print(system.time(loopy_sample3(popn, n, num)))
print("Using the vectorized sapply function (on a list) took:" )
print(system.time(sapply_sample(popn, n, num)))
print("Using the vectorized lapply function (on a list) took:" )
print(system.time(lapply_sample(popn, n, num)))
source("code/sample.R")
source("code/sample.R")
